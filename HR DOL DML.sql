

/*DDL, DML, 제약 조건*/

/*
    SQL(Structured Query Language):에스큐엘, 씨퀄, 구조화된 질의 언어

select 컬럼명
from 테이블명[뷰]
where 조건
group by 컬럼[그룹핑]
having 조건[group by 결과의 조건]
order by 정렬컬럼

SQL : 구문의 종류를 분류

DDL : (Data Definition Language) : 객체(테이블, 함수, 뷰, 트리거, 저장프로시져, 인덱스, 기타등등)를 생성하는 언어(구문)
                                 : 스키마(틀,객체)를 생성하는 언어
        --create(생성), alter(수정), drop(삭제)
        
DML : (Data Manipulation Language) : 테이블의 레코드를 조작언어<==트랜잭션을 발생 시킴(commit, rollback)
   --오라클에서는 트랜잭션 시작은 자동으로 작동됨.
   --트랜잭션을 완료 해야 한다.(commit, rollback)  
   <==트랜잭션을 완료하지 않으면 LOCK 이 걸려서 다른 사용자가 접근이 안됨
    -insert(입력), update(수정), delete(삭제)
    
DCL : (Data Controller Language) : 데이터 제어 언어, 계정에 권환을 부여, 수정, 제거
    --grant(권한을 부여), revoke(권한을 취소)
    
=======================================================

DQL : (Data Query Language) : 데이터 질의 언어(출력), 
        -Select
TCL : (Transaction Control Language):트랜잭션 제어 언어, <== DML에서 발생됨
    --begin transaction : 트랜잭션 자동으로 시작(insert, update, delect)

    --commit [transction] : 트랜잭션을 완료, 실제 DataBase 에 영구적으로 저장
    -- rollback [transction] : 트랜잭션을 시작시점으로 되돌림.

    --savepoint : 트랜잭션의 임시 저장 시점 설정

*/


--테이블 생성 : create table

create table dept (
    dno number(2) not null , 
    dname varchar2(50) not null,
    loc varchar2(13) null
);


desc dept; --테이블 구조 확인

--테이블에 값 넣기
--begin transaction;
insert into dept (dno , dname , loc )
values(10, '인사부', '서울');

rollback;
commit;


select * from dept;

/*

트랜잭션(Transaction : 작업(일)을 처리하는 최소 단위
    -- DBMS : 네트워크를 통해서 여러명의 사용자가 동시에 작업
    -- 작업을 할때 LOCK을 걸고 완료되면 LOCK을 풀어준다.
    --DML 문에서 작동,
    -- 트랜잭션을 종료하기 전까지는 Lock이 걸려서 다른 사용자의 접근을 차단
    -- commit : RAM의 수정된 내용을 DB에 영구적으로 저장
    -- rollback : 트랜잭션 시작 시점으로 되돌림.
    -- commit 전까지는 RAM 에서만 적용되어 있음.
    
    -- 트랜잭션의 4가지 특징
         --ALL or NOTHING : 되면 전부 되게 하거나 아니면 원래로 되돌리거나
    
            -- 원자성(Atomicity) : 일을처리하는 최소 단위
            -- 일관성(Consistency) : 트랜잭션 에서 처리한 결과는 일관성을 가지고 있다.
            -- 독립성(Isolation) : 하나의 트랜잭션은 다른 트랜잭션과 격리, LOCK
            -- 지속성(durability) : commit 트랜잭션은 DB에 영구히 저장된다.
            -- log에 기록됨, "트랜잭션 로그"    <==백업시점이 아니라 오류시점까지 복구
            
    
    
         
        A가 B에게 100억 입금 예 : 두 update 구문이 하나의 트랜잭션으로 작동되어야함.
        
        1.update 문을 사용해서 A 통장 100억을 출금
        
        2.update 문을 사용해서 B 통장 100억을 입금

*/

--insert 문
desc dept;

insert into dept (loc,dname, dno)
values('부산', '관리부', 20);

--컬럼이 생략 되면 모든 컬럼에 값을 할당
insert into dept
values (30,'영업부', null);

select * from dept;

insert into dept(dno, dname)
values(40, '광주');

commit;

select * from dept;

--UPDATE : 수정       <==주의 : 반드시 where 조건(Primary Key, Unique 컬럼)을 사용해야 한다.

update dept
set dname = '제조부'
where dno = 40;             --

rollback;
commit;

insert into dept(dno, dname)
values(40,'판매부');

-- dno : where 절 사용, 중복된 값이 저장되지 않는 컬럼을 사용(primary key, Unique)
update dept
set dname = 'HR', loc = '대전'
where dno = 40;

--테이블에는 Primary Key 컬럼이 존재해야 한다. <== 중복된 값을 넣을 수 없도록 제약을 설정


--delete : 테이블의 특정 레코드 삭제 : 주의 :반드시 where 조건(Primary Key, Unique 컬럼)을 사용해야 한다.
delete dept
where dno = 40;

commit;

/*
제약 조건 : 컬럼에 부여되는 제약,primary key, unique ,Not null, Check,Foreign Key/,default
      특정 컬럼에 무결성을 확보하기 위해서 부여
    Primary Key :
            --중복된 값을 넣지 못하도록 설정
            -- NOT NULL
            -- 테이블에 한번만 넣을 수 있다. 여러 컬럼에 하나의 Primary Key를 넣을 수 있다.
            --INDEX 가 자동으로 생성된다.    <==검색을 빠르게 함.
            --update, delete 시 where절에서 사용되는 컬럼
            -- JOIN 시 On 절에서 사용되는 컬럼
         Unique:
            -- 중복된 값을 넣을 수 없다.
            -- null             <== 1번만 넣을 수 있다.
            -- not null컬럼에도 생성 가능
            -- 하나의 테이블에 여러번 넣을 수 있다.
            -- INDEX 가 자동으로 생성됨     <== 검색을 빠르게 함.
            -- --update, delete 시 where절에서 사용되는 컬럼
       Not null 
            --반드시 값이 입력되어야 한다. NULL을 넣을 수 없도록
      Check
            -- 컬럼에 들어오는 값을 체크해서 저장,조건에 만족하는 값만 넣도록         age>0 
      Foreign Key
            -- 부모테이블의 특정 컬럼을 참조해서 값을 넣을 수 있도록 설정
            -- 부모 테이블의 참조 하는 컬럼은 primary Key, Unique 키 컬럼을 참조
      
      Default : 컬럼의 값을 넣지 않는 경우 default로 설정된 값이 자동으로 들어감.       
          --제약조건이 아니여서 제약 조건 이름을 부여할 수 없다.
          --null, not null 앞에 처리해야 함.<<주의>>
      데이터 사전 : 오라클에서 테이블에 대한 각종 정보를 저장한 테이블
            user_constraints                        -- 제약 조건을 확인하는 데이터 사전
            select * from user_constraints

*/

create table member1(
    id varchar2(50) not null primary key,
    pass varchar2(50) not null,
    addr varchar2(100) null,
    phone varchar2(30) null,
    age number (3),             -- 정수 3자리    
    weight number(5,2)          -- 실수 : 전체 5자리, 소숫점이하 2자리  
);

--Insert
insert into member1 
values('ddd','aaa','서울','010-1111-1111',20,70.55);

select * from member1;


commit;

--update 시 where 조건에 primaty key 컬럼을 조건으로 처리

update member1
set addr='부산', phone='010-2222-2222',age=30,weight=88.55
where id ='bbb'

select * from member1

--delete 시 where 조건에 primaty key 컬럼을 조건으로 처리
delete member1
where id = 'ccc';

/*Unique*/

create table member2(
    id varchar2(50) not null primary key,
    pass varchar2(50) not null Unique,
    addr varchar2(100) null,
    phone varchar2(30) null Unique,
    age number (3),                
    weight number(5,2)          
);

--Insert
insert into member2 
values('bbbb','bbbbb','서울','010-2222-2222',10,70.55);

select * from member2;
commit;

-- 오라클의 데이터 사전을 사용해서 member2 테이블의 제약 조건을 확인
show user;    -- 현재 접속한 계정 정보를 출력 : C##HR

select * from user_constraints
where table_name = 'MEMBER2';


--테이블 생성시 제약 조건 이름을 부여하면서 제약조건 할당
-- 제약 조건 이름은 : PK_테이블이름_컬럼명

create table member3(
    id varchar2(50) not null constraint PK_MEMBER3_ID primary key,
    pass varchar2(50) not null constraint PK_MEMBER3_PASS Unique,
    addr varchar2(100) null,
    phone varchar2(30) null constraint PK_MEMBER3_PHONE Unique,
    age number (3),                
    weight number(5,2)          
);

insert into member3 
values('bb','bb','서울','010-1111-2222',10,70.55);


select * from member3;
commit;

/*check : 컬럼의 값을 체크*/

create table member4(
    id varchar2(50) not null constraint PK_MEMBER4_ID primary key,
    pass varchar2(50) not null constraint U_MEMBER4_PASS Unique,
    addr varchar2(100) null,
    phone varchar2(30) null constraint U_MEMBER4_PHONE Unique,
    age number (3) constraint CK_MEMBER4_AGE  check(age > 0 and age < 150 ),
    gender char(1)  constraint CK_MEMBER4_GENDER check(gender in('W','M')), 
    weight number(5,2)          
);

--제약 조건 출력

select * from user_constraints
where table_name = 'MEMBER4';

insert into member4 
values('b','b','서울','010-1111-2222',70,'M', 70.55);


select * from member3;
commit;

/* Default: 값을 넣지 않으면 default 로 설정된 값이 자동으로 들어감*/

create table member5(
    id varchar2(50) not null constraint PK_MEMBER5_ID primary key,
    pass varchar2(50) not null constraint U_MEMBER5_PASS Unique,
    addr varchar2(100) default '서울' null,
    phone varchar2(30) null constraint U_MEMBER5_PHONE Unique,
    age number (3) null constraint CK_MEMBER5_AGE  check(age > 0 and age < 150 ),
    gender char(1) null constraint CK_MEMBER5_GENDER check(gender in('W','M')), 
    weight number(5,2) default 10.00 null,
    hiredate date default sysdate
);

drop table member5;

--insert : default에 값 할당 : default 키를 사용하는 경우
insert into member5 
values('b','b','default','010-1111-2222',70,'M', default, default);

--insert : default에 값 할당 : 컬럼이 명시 되지 않는 경우
insert into member5(id, pass, phone, age, gender)
values('c','c','010-1111-3333',70,'M');


select * from member5;
commit;

/*Foreign Key: 부모 테이블의 특정컬럼을 참조해서 값을 넣도록 설정
        - 부모 테이블의 primary key, unique 키 컬럼을 참조
        - Foreign Key는 자식 테이블의 특정 컬럼에 넣는다.
*/

--employee 테이블의 
select * from department;       --부서 정보를 저장하는 테이블(부모 테이블) dno
select * from employee;         -- 사원 정보를 저장하는 테이블 (자식 테이블 : Foreign Key(dno))






































































